<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Color & Text Extraction</title>
    <script src="https://unpkg.com/tesseract.js@4/dist/tesseract.min.js"></script>
</head>
<body>
    <h1>Test Color & Text Extraction</h1>
    <input type="file" id="fileInput" accept="image/*">
    <div id="results"></div>
    
    <script type="module">
        // Copy the BrowserExtractor logic here for testing
        class BrowserExtractor {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
            }
            
            async extractAll(file, onProgress) {
                const startTime = Date.now();
                
                onProgress?.('Loading image', 0);
                const img = await this.loadImage(file);
                
                onProgress?.('Extracting colors', 25);
                const colors = await this.extractColors(img);
                
                onProgress?.('Extracting text', 50);
                const text = await this.extractText(file, onProgress);
                
                onProgress?.('Complete', 100);
                
                return {
                    colors,
                    text,
                    metadata: {
                        imageWidth: img.width,
                        imageHeight: img.height,
                        extractionTime: Date.now() - startTime,
                        timestamp: new Date().toISOString()
                    }
                };
            }
            
            async loadImage(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const url = URL.createObjectURL(file);
                    
                    img.onload = () => {
                        URL.revokeObjectURL(url);
                        resolve(img);
                    };
                    
                    img.onerror = reject;
                    img.src = url;
                });
            }
            
            async extractColors(img) {
                const maxDimension = 500;
                const aspectRatio = img.width / img.height;
                
                const width = img.width > img.height ? maxDimension : maxDimension * aspectRatio;
                const height = img.height > img.width ? maxDimension : maxDimension / aspectRatio;
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.ctx.drawImage(img, 0, 0, width, height);
                
                const imageData = this.ctx.getImageData(0, 0, width, height);
                const pixels = imageData.data;
                
                const colorMap = new Map();
                
                for (let i = 0; i < pixels.length; i += 4) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    const a = pixels[i + 3];
                    
                    if (a < 128) continue;
                    
                    const hex = this.rgbToHex(r, g, b);
                    colorMap.set(hex, (colorMap.get(hex) || 0) + 1);
                }
                
                const sortedColors = Array.from(colorMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .map(([hex, count]) => ({
                        hex,
                        usage: count
                    }));
                
                return {
                    primary: sortedColors[0]?.hex || '#000000',
                    secondary: sortedColors[1]?.hex || '#FFFFFF',
                    background: sortedColors[sortedColors.length - 1]?.hex || '#FFFFFF',
                    text: sortedColors.slice(0, 3).map(c => c.hex),
                    palette: sortedColors
                };
            }
            
            async extractText(file, onProgress) {
                try {
                    const result = await Tesseract.recognize(file, 'eng', {
                        logger: (m) => {
                            if (m.status === 'recognizing text' && onProgress) {
                                onProgress('[OCR] Progress', Math.round(m.progress * 100));
                            }
                        }
                    });
                    
                    return {
                        extracted: result.data.text.trim(),
                        confidence: Math.round(result.data.confidence),
                        blocks: []
                    };
                } catch (error) {
                    console.error('OCR extraction failed:', error);
                    return {
                        extracted: '',
                        confidence: 0,
                        blocks: []
                    };
                }
            }
            
            rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
            }
        }
        
        // Test the extractor
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const extractor = new BrowserExtractor();
            const resultsDiv = document.getElementById('results');
            
            resultsDiv.innerHTML = '<p>Extracting...</p>';
            
            try {
                const data = await extractor.extractAll(file, (stage, progress) => {
                    resultsDiv.innerHTML = `<p>${stage}: ${progress}%</p>`;
                });
                
                resultsDiv.innerHTML = `
                    <h2>Extraction Results</h2>
                    <h3>Colors Found:</h3>
                    <div style="display: flex; gap: 10px;">
                        ${data.colors.palette.map(c => `
                            <div style="text-align: center;">
                                <div style="width: 50px; height: 50px; background: ${c.hex}; border: 1px solid black;"></div>
                                <small>${c.hex}</small>
                            </div>
                        `).join('')}
                    </div>
                    <h3>Text Extracted (${data.text.confidence}% confidence):</h3>
                    <pre style="background: #f0f0f0; padding: 10px; white-space: pre-wrap;">${data.text.extracted || 'No text found'}</pre>
                    <h3>Metadata:</h3>
                    <pre>${JSON.stringify(data.metadata, null, 2)}</pre>
                `;
            } catch (error) {
                resultsDiv.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
            }
        });
    </script>
</body>
</html>